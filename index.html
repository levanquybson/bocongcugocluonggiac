
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Góc lượng giác — Bộ công cụ trực quan</title>

  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <!-- MathJax (giữ để render công thức) -->
  <script>
    window.MathJax = { tex: { inlineMath: [['\\(','\\)'], ['$', '$']] } };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --card:#ffffffcc; --border:#e6ecf2; --shadow:0 10px 28px rgba(15,23,42,.12);
      --primary:#1e88e5; --primary-600:#1565c0; --primary-700:#0d47a1;
      --violet:#7b1fa2; --violet-700:#4a148c;
      --ink:#0f172a;
    }
    *{box-sizing:border-box}
    body{
      font-family:"Inter",sans-serif; margin:0; padding:28px; color:var(--ink);
      background: radial-gradient(1200px 600px at 20% -10%, #eef4ff 0%, transparent 60%),
                  radial-gradient(1000px 800px at 100% 0%, #fff7e6 0%, transparent 50%),
                  #f6f8ff;
    }
    h1{margin:0 0 14px; text-align:center; font-weight:800; color:var(--primary-600)}

    /* Nút tab */
    .tabs{
      display:flex; gap:14px; justify-content:center; align-items:center; margin:18px 0 10px;
    }
    .tab{
      position:relative; padding:12px 22px; border:none; border-radius:14px; font-weight:700;
      color:#fff; cursor:pointer; transition:transform .22s ease, box-shadow .22s ease, filter .2s;
      box-shadow:0 8px 18px rgba(0,0,0,.15);
      outline:none;
    }
    .tab:active{ transform:scale(.97) }
    .tab.primary{
      background:linear-gradient(135deg, var(--primary), var(--primary-600));
    }
    .tab.secondary{
      background:linear-gradient(135deg, var(--violet), var(--violet-700));
    }
    .tab.active{
      filter:brightness(1.08);
      box-shadow:0 10px 22px rgba(0,0,0,.22);
    }

    /* Dải quote */
    .quote{
      text-align:center; color:#e11d48; font-weight:800; font-style:italic;
      font-size:1.1rem; margin:12px 0 18px;
    }

    /* Khối view (mỗi “trang”) */
    .view{ display:none; }
    .view.active{ display:block; }

    /* Layout chung cho mỗi view */
    .layout{
      display:flex; gap:18px; justify-content:center; align-items:flex-start; flex-wrap:wrap;
    }
    .panel{
      width:340px; background:var(--card); border:1px solid var(--border); border-radius:16px;
      box-shadow:var(--shadow); padding:16px; display:flex; flex-direction:column; gap:14px;
      backdrop-filter:blur(6px);
    }
    .panel-title{font-weight:800; color:#0b2a4a}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row label{font-weight:600; min-width:96px}
    input{
      flex:1; padding:9px 12px; border:1px solid #cbd5e1; border-radius:12px;
      font-size:1rem; text-align:center; background:#fff;
    }
    input[readonly]{background:#f6f7fb; color:#334155; border-style:dashed}
    button.action{
      padding:9px 16px; border:none; background:var(--primary); color:#fff;
      border-radius:12px; font-size:1rem; cursor:pointer; font-weight:700;
      box-shadow:0 6px 16px rgba(30,136,229,.35);
      transition:transform .18s ease, box-shadow .18s ease, filter .18s ease;
    }
    button.action:hover{ transform:translateY(-2px); box-shadow:0 10px 22px rgba(30,136,229,.45); filter:brightness(1.03)}
    #info1,#info2{
      font-weight:800; color:#0b2a4a; background:#f1f5ff; border:1px dashed #c7d7ff;
      padding:10px; border-radius:12px; line-height:1.4
    }
    .formula{color:#334155; font-size:.95rem; text-align:center}

    /* Canvas */
    canvas{
      background:#fff; border:1px solid #e5e7eb; border-radius:16px; box-shadow:var(--shadow);
      cursor:grab;
    }
    canvas:active{ cursor:grabbing }

.row {
  display: flex;
  align-items: center;
  gap: 8px;          /* khoảng cách giữa label và input */
}

.row label {
  min-width: unset;  /* bỏ chiều rộng tối thiểu */
  white-space: nowrap; /* không cho xuống dòng */
}
.row input {
  flex: 1;           /* input giãn ra hết phần còn lại */
}


  </style>
</head>
<body>
  <h1>BỘ CÔNG CỤ GÓC LƯỢNG GIÁC</h1>
  <div class="quote">“Lượng giác là ngôn ngữ của dao động và vòng tròn.”</div>

  <!-- Tabs -->
  <div class="tabs">
    <button id="btnAngle" class="tab primary active">✨ Góc lượng giác</button>
    <button id="btnRepr"  class="tab secondary">✨ Điểm biểu diễn góc lượng giác</button>
  </div>


  <!-- View 1: Góc lượng giác -->
  <section id="view-angle" class="view active">
    <div class="layout">
      <aside class="panel">
        <div class="panel-title">Nhập góc lượng giác hoặc rê điểm M</div>
        <div class="row">
  <label>Độ (°):</label>
  <input type="number" id="degInput1" value="0" step="1">
</div>
        <div class="row">
          <label>Radian:</label>
          <input type="text" id="radInput1" value="0" readonly>
        </div>
<div class="row">
  <label>Góc xOy (°):
  <input type="number" id="betaInput1" value="45" step="1"></label>

</div>

        <div id="info1">
          α = <span id="degShow1">0</span> (<span id="radShow1">0</span> rad)<br>
          k = <span id="kShow1">0</span> vòng quay<br>
          chiều <span id="sgnShow1">0</span>
        </div>

        <div class="row"><button id="resetBtn1" class="action">Đưa về 0°</button></div>
        <div class="formula">Công thức quy đổi: \( \alpha^{\circ} = \dfrac{\alpha\pi}{180}\,\text{rad} \)</div>
      </aside>

      <section>
        <canvas id="canvas1" width="700" height="500"></canvas>
      </section>
    </div>
  </section>

  <!-- View 2: Biểu diễn góc lượng giác -->
  <section id="view-repr" class="view">
    <div class="layout">
      <aside class="panel">
        <div class="panel-title">Nhập & thông tin (Biểu diễn)</div>
        <div class="row">
          <label>Độ (°):</label>
          <input type="number" id="degInput2" value="0" step="1">
        </div>
        <div class="row">
          <label>Radian:</label>
          <input type="text" id="radInput2" value="0" readonly>
        </div>
        <div class="row">
          <label>Góc xOy (°):
          <input type="number" id="betaInput2" value="90" step="1"></label>
        </div>

        <div id="info2">
          α = <span id="degShow2">0</span> (<span id="radShow2">0</span> rad)<br>
          k = <span id="kShow2">0</span> vòng quay<br>
          theo chiều <span id="sgnShow2">0</span>
        </div>

        <div class="row"><button id="resetBtn2" class="action">Đưa về 0°</button></div>
        <div class="formula">Công thức quy đổi: \( \alpha^{\circ} = \dfrac{\alpha\pi}{180}\,\text{rad} \)</div>
      </aside>

      <section>
        <canvas id="canvas2" width="760" height="540"></canvas>
      </section>
    </div>
  </section>

  <script>
    // ========= Helpers chung =========
    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;
    function gcd(a,b){a=Math.abs(a);while(b){[a,b]=[b,a%b]}return a||1}
    function degToPiFrac(deg){
      if(deg===0) return "0";
      const sign = deg<0 ? "-" : "";
      let num = Math.abs(Math.round(deg)), den = 180;
      const g = gcd(num,den); num/=g; den/=g;
      if(den===1) return sign + (num===1 ? "π" : num+"π");
      return sign + (num===1 ? "π" : num+"π") + "/" + den;
    }
    function drawArrowHead(ctx,x,y,dx,dy,color){
      const L=Math.hypot(dx,dy); if(L<1e-6) return; dx/=L; dy/=L;
      ctx.save(); ctx.translate(x,y); ctx.rotate(Math.atan2(dy,dx));
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-9,4.5); ctx.lineTo(-9,-4.5); ctx.closePath();
      ctx.fillStyle=color; ctx.fill(); ctx.restore();
    }
    function niceHsl(isPos,t){ const hue=isPos?210:0, sat=70, light=62-22*t; return `hsl(${hue} ${sat}% ${light}%)`; }

    // ========= View 1: Góc lượng giác =========
    (function(){
      const canvas = document.getElementById('canvas1');
      const ctx = canvas.getContext('2d');
      const cx = canvas.width/2, cy = canvas.height/2;

      const degInput = document.getElementById('degInput1');
      const radInput = document.getElementById('radInput1');
      const betaInput = document.getElementById('betaInput1');
      const degShow = document.getElementById('degShow1');
      const radShow = document.getElementById('radShow1');
      const kShow = document.getElementById('kShow1');
      const sgnShow = document.getElementById('sgnShow1');
      const resetBtn = document.getElementById('resetBtn1');

      let alphaDeg = 0, betaDeg = 45;
      let dragging=false, lastRaw=0, ignoreSync=false;

      function drawAxes(){
        ctx.save();

        // Ox: từ O sang phải, mũi tên ở đầu dương
        const xRight = canvas.width - 40;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(xRight, cy);
        ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2.4; ctx.stroke();
        drawArrowHead(ctx, xRight, cy, 1, 0, '#0f172a');
        ctx.fillStyle='#0b2a4a'; ctx.font='14px Inter'; ctx.fillText('x', xRight-12, cy-10);

        // Oy: là tia qua O với góc betaDeg, mũi tên ở đầu dương
        const len=270, ang=toRad(betaDeg);
        const xOy=cx+len*Math.cos(ang), yOy=cy-len*Math.sin(ang);
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(xOy,yOy);
        ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2.4; ctx.stroke();
        drawArrowHead(ctx, xOy, yOy, Math.cos(ang), -Math.sin(ang), '#0f172a');
        ctx.fillText('y', xOy+8, yOy+4);

        // O
        ctx.beginPath(); ctx.arc(cx,cy,3,0,2*Math.PI); ctx.fillStyle='#000'; ctx.fill();
        ctx.fillText('O', cx-18, cy+16);

   
      }

      function drawArc(){
        const rad = toRad(alphaDeg);
        if(Math.abs(rad)<1e-6) return;
        if(Math.abs(rad) < 2*Math.PI){
          const r=42, steps=Math.max(28, Math.ceil(Math.abs(rad)/0.045)), isPos=rad>=0;
          ctx.save(); ctx.lineWidth=1.8; let prevX=cx+r, prevY=cy;
          for(let i=1;i<=steps;i++){
            const t=(i/steps)*rad, x=cx+r*Math.cos(t), y=cy-r*Math.sin(t), ratio=i/steps;
            ctx.beginPath(); ctx.moveTo(prevX,prevY); ctx.lineTo(x,y);
            ctx.strokeStyle=niceHsl(isPos,ratio); ctx.stroke(); prevX=x; prevY=y;
          }
          const t=rad, s=Math.sign(rad)||1, x=cx+r*Math.cos(t), y=cy-r*Math.sin(t);
          const dx=-s*r*Math.sin(t), dy=-s*r*Math.cos(t);
          drawArrowHead(ctx, x, y, dx, dy, niceHsl(isPos,.95));
          const mid=rad/2; ctx.fillStyle=niceHsl(isPos,.35); ctx.font='16px Inter';
          ctx.fillText('α', cx+(r+22)*Math.cos(mid), cy-(r+22)*Math.sin(mid)); ctx.restore();
        } else {
          // Spiral khi vượt 2π
          const dir=rad>=0?1:-1, isPos=dir>0; const a=10,b=3,absR=Math.abs(rad);
          ctx.save(); ctx.lineWidth=1.8; let prevX,prevY; const step=0.045;
          for(let t=0;t<=absR+1e-6;t+=step){
            const ratio=Math.min(1,t/absR), r=a+b*t;
            const x=cx+r*Math.cos(dir*t), y=cy-r*Math.sin(dir*t);
            if(t===0){prevX=x; prevY=y; continue;}
            ctx.beginPath(); ctx.moveTo(prevX,prevY); ctx.lineTo(x,y);
            ctx.strokeStyle=niceHsl(isPos,ratio); ctx.stroke(); prevX=x; prevY=y;
          }
          const t=absR, r=a+b*t, x1=cx+r*Math.cos(dir*t), y1=cy-r*Math.sin(dir*t);
          const dt=0.001, r2=a+b*(t+dt);
          const x2=cx+r2*Math.cos(dir*(t+dt)), y2=cy-r2*Math.sin(dir*(t+dt));
          drawArrowHead(ctx, x1,y1, x2-x1, y2-y1, niceHsl(isPos,.92));
          ctx.fillStyle=niceHsl(isPos,.4); ctx.font='16px Inter'; ctx.fillText('α', x1+14, y1+16); ctx.restore();
        }
      }

      function drawOM(){
        const r=220, rad=toRad(alphaDeg);
        const Mx=cx+r*Math.cos(rad), My=cy-r*Math.sin(rad);
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(Mx,My);
        ctx.strokeStyle='#00897b'; ctx.lineWidth=2; ctx.stroke();
        ctx.beginPath(); ctx.arc(Mx,My,6,0,2*Math.PI); ctx.fillStyle='#00bcd4'; ctx.fill();
        ctx.fillStyle='#0f172a'; ctx.font='14px Inter'; ctx.fillText("M", Mx+10, My-10);
      }

      function redraw(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawAxes(); drawArc(); drawOM();

        const dInt = Math.round(alphaDeg);
        const k = Math.floor(dInt/360);
        const base = dInt - k*360;
        const sign = alphaDeg>0?"dương":(alphaDeg<0?"âm":"0");

        let degDisplay = base + "°";
        if(k!==0) degDisplay += (k>0?" + ":" − ") + Math.abs(k) + "·360°";
        degShow.textContent = degDisplay;

        let radDisplay = degToPiFrac(base);
        if(k!==0) radDisplay += (k>0?" + ":" − ") + Math.abs(k) + "·2π";
        radShow.textContent = radDisplay;

        kShow.textContent = k; sgnShow.textContent = sign;

        if(!ignoreSync){
          ignoreSync = true;
          degInput.value = dInt;
          radInput.value = degToPiFrac(dInt);
          betaInput.value = betaDeg;
          ignoreSync = false;
        }
      }

      // Drag M
      function getPos(evt){ const r=canvas.getBoundingClientRect();
        const x = (evt.touches?evt.touches[0].clientX:evt.clientX) - r.left;
        const y = (evt.touches?evt.touches[0].clientY:evt.clientY) - r.top;
        return {x,y};
      }
      function rawAngleDegAt(p){ return toDeg(Math.atan2(cy-p.y, p.x-cx)); }
      function onDown(e){
        const p=getPos(e), r=220;
        const Mx=cx+r*Math.cos(toRad(alphaDeg)), My=cy-r*Math.sin(toRad(alphaDeg));
        if(Math.hypot(p.x-Mx,p.y-My)<14){ dragging=true; lastRaw=rawAngleDegAt(p); e.preventDefault(); }
      }
      function onMove(e){
        if(!dragging) return;
        const p=getPos(e), now=rawAngleDegAt(p);
        let d=now-lastRaw; if(d>180)d-=360; if(d<-180)d+=360;
        alphaDeg += d; lastRaw = now; redraw(); e.preventDefault();
      }
      function onUp(){ dragging=false; }

      // Bind
      degInput.addEventListener('input', ()=>{ if(ignoreSync) return; alphaDeg=parseInt(degInput.value)||0; redraw(); });
      betaInput.addEventListener('input', ()=>{ if(ignoreSync) return; betaDeg=parseInt(betaInput.value)||45; redraw(); });
      resetBtn.addEventListener('click', ()=>{ alphaDeg=0; redraw(); });

      canvas.addEventListener('mousedown',onDown);
      canvas.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp);
      canvas.addEventListener('touchstart',onDown,{passive:false});
      canvas.addEventListener('touchmove',onMove,{passive:false});
      window.addEventListener('touchend',onUp);

      // Expose để tab kích hoạt có thể redraw
      window.__redrawView1 = redraw;

      redraw();
    })();

    // ========= View 2: Biểu diễn góc lượng giác =========
    (function(){
      const canvas = document.getElementById('canvas2');
      const ctx = canvas.getContext('2d');
      const cx = canvas.width/2, cy = canvas.height/2;

      const degInput = document.getElementById('degInput2');
      const radInput = document.getElementById('radInput2');
      const betaInput = document.getElementById('betaInput2');
      const degShow = document.getElementById('degShow2');
      const radShow = document.getElementById('radShow2');
      const kShow = document.getElementById('kShow2');
      const sgnShow = document.getElementById('sgnShow2');
      const resetBtn = document.getElementById('resetBtn2');

      let alphaDeg = 0, betaDeg = 90; // Oy mặc định thẳng đứng
      let dragging=false, lastRaw=0, ignoreSync=false;

      function drawAxes(){
        ctx.save();
        // Ox (nguyên trục, mũi tên ở đầu dương)
        const xLeft = 40, xRight = canvas.width - 40;
        ctx.beginPath(); ctx.moveTo(xLeft, cy); ctx.lineTo(xRight, cy);
        ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2.4; ctx.stroke();
        drawArrowHead(ctx, xRight, cy, 1, 0, '#0f172a');
        ctx.fillStyle = '#0b2a4a'; ctx.font = '14px Inter'; ctx.fillText('x', xRight-12, cy-10);

        // Oy (nguyên trục, mũi tên ở đầu dương — cho phép xoay theo betaDeg)
        const yTop = 40, yBottom = canvas.height - 40;
        const ang = toRad(betaDeg); // góc của Oy so với Ox
        // Tạo hai điểm đầu/cuối theo hướng Oy đi qua O (cx,cy)
        const lenTop = yBottom - yTop;
        const yx1 = cx - Math.cos(ang)* (lenTop/2), yy1 = cy + Math.sin(ang)* (lenTop/2);
        const yx2 = cx + Math.cos(ang)* (lenTop/2), yy2 = cy - Math.sin(ang)* (lenTop/2);
        // Vẽ đường thẳng Oy
        ctx.beginPath(); ctx.moveTo(yx1, yy1); ctx.lineTo(yx2, yy2);
        ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2.4; ctx.stroke();
        // Đặt mũi tên ở đầu dương (phía x2,y2 theo hướng +)
        drawArrowHead(ctx, yx2, yy2, Math.cos(ang), -Math.sin(ang), '#0f172a');
        ctx.fillText('y', yx2+8, yy2+4);

        // O
        ctx.beginPath(); ctx.arc(cx,cy,3,0,2*Math.PI); ctx.fillStyle='#000'; ctx.fill();
        ctx.fillText('O', cx-18, cy+16);
        ctx.restore();
      }

      function drawCircleAndPoints(){
        const rCircle = 200;
        ctx.save();
        // Đường tròn
        ctx.beginPath(); ctx.lineWidth=1.5; ctx.strokeStyle='#555';
        ctx.arc(cx, cy, rCircle, 0, Math.PI*2); ctx.stroke();

        // A,C trên Ox
        const Ax = cx + rCircle, Ay = cy;
        const Cx = cx - rCircle, Cy = cy;

        // B,D trên Oy (xoay theo betaDeg)
        const ang = toRad(betaDeg);
        const Bx = cx + rCircle * Math.cos(ang);
        const By = cy - rCircle * Math.sin(ang);
        const Dx = cx - rCircle * Math.cos(ang);
        const Dy = cy + rCircle * Math.sin(ang);

        function dot(x,y,label, ox=10, oy=-8){
          ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fillStyle='#d32f2f'; ctx.fill();
          ctx.fillStyle='#0f172a'; ctx.font='14px Inter'; ctx.fillText(label, x+ox, y+oy);
        }
        dot(Ax,Ay,'A', -16,-8);
        dot(Cx,Cy,'C', -18,-8);
        dot(Bx,By,'B', 10,-4);
        dot(Dx,Dy,'D', 10,20);

        ctx.restore();
      }

      function drawOM(){
        const r=200, rad=toRad(alphaDeg);
        const Mx=cx+r*Math.cos(rad), My=cy-r*Math.sin(rad);
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(Mx,My);
        ctx.strokeStyle='#00897b'; ctx.lineWidth=2; ctx.stroke();
        ctx.beginPath(); ctx.arc(Mx,My,6,0,2*Math.PI); ctx.fillStyle='#00bcd4'; ctx.fill();
        ctx.fillStyle='#0f172a'; ctx.font='14px Inter';
        ctx.fillText("M", Mx+10, My-10);

        // Nhãn α trên tiếp tuyến nhỏ ở O
        const r0=40, t=toRad(alphaDeg), x=cx+r0*Math.cos(t/2), y=cy-r0*Math.sin(t/2);
        ctx.fillText("α = "+Math.round(alphaDeg)+"°", Mx+12, My+18);
      }

      function drawArc(){
        const rad = toRad(alphaDeg); if(Math.abs(rad)<1e-6) return;
        if(Math.abs(rad) < 2*Math.PI){
          const r=42, steps=Math.max(28, Math.ceil(Math.abs(rad)/0.045)), isPos=rad>=0;
          ctx.save(); ctx.lineWidth=1.8; let prevX=cx+r, prevY=cy;
          for(let i=1;i<=steps;i++){
            const t=(i/steps)*rad, x=cx+r*Math.cos(t), y=cy-r*Math.sin(t), ratio=i/steps;
            ctx.beginPath(); ctx.moveTo(prevX,prevY); ctx.lineTo(x,y);
            ctx.strokeStyle=niceHsl(isPos,ratio); ctx.stroke(); prevX=x; prevY=y;
          }
          const t=rad, s=Math.sign(rad)||1, x=cx+r*Math.cos(t), y=cy-r*Math.sin(t);
          const dx=-s*r*Math.sin(t), dy=-s*r*Math.cos(t);
          drawArrowHead(ctx, x, y, dx, dy, niceHsl(isPos,.95));
          const mid=rad/2; ctx.fillStyle=niceHsl(isPos,.35); ctx.font='16px Inter';
          ctx.fillText('α', cx+(r+22)*Math.cos(mid), cy-(r+22)*Math.sin(mid)); ctx.restore();
        } else {
          const dir=rad>=0?1:-1, isPos=dir>0; const a=10,b=3,absR=Math.abs(rad);
          ctx.save(); ctx.lineWidth=1.8; let prevX,prevY; const step=0.045;
          for(let t=0;t<=absR+1e-6;t+=step){
            const ratio=Math.min(1,t/absR), r=a+b*t;
            const x=cx+r*Math.cos(dir*t), y=cy-r*Math.sin(dir*t);
            if(t===0){prevX=x; prevY=y; continue;}
            ctx.beginPath(); ctx.moveTo(prevX,prevY); ctx.lineTo(x,y);
            ctx.strokeStyle=niceHsl(isPos,ratio); ctx.stroke(); prevX=x; prevY=y;
          }
          const t=absR, r=a+b*t, x1=cx+r*Math.cos(dir*t), y1=cy-r*Math.sin(dir*t);
          const dt=0.001, r2=a+b*(t+dt);
          const x2=cx+r2*Math.cos(dir*(t+dt)), y2=cy-r2*Math.sin(dir*(t+dt));
          drawArrowHead(ctx, x1,y1, x2-x1, y2-y1, niceHsl(isPos,.92));
          ctx.fillStyle=niceHsl(isPos,.4); ctx.font='16px Inter'; ctx.fillText('α', x1+14, y1+16); ctx.restore();
        }
      }

      function redraw(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawAxes(); drawCircleAndPoints(); drawArc(); drawOM();

        const dInt = Math.round(alphaDeg);
        const k = Math.floor(dInt/360);
        const base = dInt - k*360;
        const sign = alphaDeg>0?"dương":(alphaDeg<0?"âm":"0");

        let degDisplay = base + "°";
        if(k!==0) degDisplay += (k>0?" + ":" − ") + Math.abs(k) + "·360°";
        degShow.textContent = degDisplay;

        let radDisplay = degToPiFrac(base);
        if(k!==0) radDisplay += (k>0?" + ":" − ") + Math.abs(k) + "·2π";
        radShow.textContent = radDisplay;

        kShow.textContent = k; sgnShow.textContent = sign;

        if(!ignoreSync){
          ignoreSync = true;
          degInput.value = dInt;
          radInput.value = degToPiFrac(dInt);
          betaInput.value = betaDeg;
          ignoreSync = false;
        }
      }

      // Drag M
      function getPos(evt){ const r=canvas.getBoundingClientRect();
        const x=(evt.touches?evt.touches[0].clientX:evt.clientX)-r.left;
        const y=(evt.touches?evt.touches[0].clientY:evt.clientY)-r.top; return {x,y};
      }
      function rawAngleDegAt(p){ return toDeg(Math.atan2(cy-p.y, p.x-cx)); }
      function onDown(e){
        const p=getPos(e), r=200;
        const Mx=cx+r*Math.cos(toRad(alphaDeg)), My=cy-r*Math.sin(toRad(alphaDeg));
        if(Math.hypot(p.x-Mx,p.y-My)<14){ dragging=true; lastRaw=rawAngleDegAt(p); e.preventDefault(); }
      }
      function onMove(e){
        if(!dragging) return;
        const p=getPos(e), now=rawAngleDegAt(p);
        let d=now-lastRaw; if(d>180)d-=360; if(d<-180)d+=360;
        alphaDeg += d; lastRaw = now; redraw(); e.preventDefault();
      }
      function onUp(){ dragging=false; }

      // Bind
      degInput.addEventListener('input', ()=>{ if(ignoreSync) return; alphaDeg=parseInt(degInput.value)||0; redraw(); });
      betaInput.addEventListener('input', ()=>{ if(ignoreSync) return; betaDeg=parseInt(betaInput.value)||90; redraw(); });
      resetBtn.addEventListener('click', ()=>{ alphaDeg=0; redraw(); });

      canvas.addEventListener('mousedown',onDown);
      canvas.addEventListener('mousemove',onMove);
      window.addEventListener('mouseup',onUp);
      canvas.addEventListener('touchstart',onDown,{passive:false});
      canvas.addEventListener('touchmove',onMove,{passive:false});
      window.addEventListener('touchend',onUp);

      // Expose cho tab
      window.__redrawView2 = redraw;

      redraw();
    })();

    // ========= Chuyển tab =========
    (function(){
      const btnAngle = document.getElementById('btnAngle');
      const btnRepr  = document.getElementById('btnRepr');
      const view1    = document.getElementById('view-angle');
      const view2    = document.getElementById('view-repr');

      function activate(which){
        if(which===1){
          btnAngle.classList.add('active'); btnRepr.classList.remove('active');
          view1.classList.add('active');     view2.classList.remove('active');
          // đảm bảo vẽ lại khi vừa hiện
          if(typeof window.__redrawView1 === 'function') window.__redrawView1();
        }else{
          btnRepr.classList.add('active');  btnAngle.classList.remove('active');
          view2.classList.add('active');     view1.classList.remove('active');
          if(typeof window.__redrawView2 === 'function') window.__redrawView2();
        }
      }

      btnAngle.addEventListener('click', ()=>activate(1));
      btnRepr .addEventListener('click', ()=>activate(2));
    })();
  </script>
</body>
</html>
